# is22 長時間運用設計

文書番号: is22_12
作成日: 2025-12-31
ステータス: Draft
参照:
- is22_Camserver仕様案 Section 5.7
- DESIGN_GAP_ANALYSIS GAP-012

---

## 1. 概要

### 1.1 目的

Camserverを長時間（24〜72時間以上）運用してもパンクしない設計を実現する。

### 1.2 設計原則

- **リングバッファ**: ログ・DOMの無限増加禁止
- **Lease/Heartbeat**: タブ放置・切断を自動回収
- **後始末必須**: WebRTC/再生リソースのクリーンアップ
- **計画リフレッシュ**: 必要に応じた定期リロード許容

---

## 2. リングバッファ設計

### 2.1 サーバー側（EventLogService）

```rust
struct EventLogRingBuffer {
    events: VecDeque<DetectionEvent>,
    capacity: usize,
}

impl EventLogRingBuffer {
    fn new(capacity: usize) -> Self {
        Self {
            events: VecDeque::with_capacity(capacity),
            capacity,
        }
    }

    fn push(&mut self, event: DetectionEvent) {
        if self.events.len() >= self.capacity {
            self.events.pop_front(); // 古いイベントを破棄
        }
        self.events.push_back(event);
    }

    fn get_latest(&self, count: usize) -> Vec<&DetectionEvent> {
        self.events.iter().rev().take(count).collect()
    }
}
```

### 2.2 パラメータ

| 項目 | サーバー側 | クライアント側 |
|-----|-----------|--------------|
| イベントログ | 2000件 | 500件 |
| フレームキャッシュ | 1000件 | N/A |
| サムネキャッシュ | 100枚×30カメラ | N/A |

### 2.3 クライアント側

```javascript
class EventLogBuffer {
    constructor(maxSize = 500) {
        this.maxSize = maxSize;
        this.events = [];
    }

    add(event) {
        this.events.push(event);
        if (this.events.length > this.maxSize) {
            this.events.shift(); // 古いイベントを破棄
        }
        this.render();
    }

    render() {
        const container = document.getElementById('event-log');
        // 既存のDOM要素を再利用または削除
        while (container.children.length > this.maxSize) {
            container.removeChild(container.firstChild);
        }
        // 新しいイベントを追加
    }
}
```

---

## 3. メモリ管理

### 3.1 サーバー側

| リソース | 管理方法 | クリーンアップ間隔 |
|---------|---------|------------------|
| EventLogRingBuffer | 固定容量 | 自動（push時） |
| ModalLease | TTL/Heartbeat | 10秒 |
| SuggestState | 単一状態 | N/A |
| サムネキャッシュ | LRU | 1分 |
| WebSocket接続 | Heartbeat監視 | 30秒 |

### 3.2 定期クリーンアップ

```rust
async fn periodic_cleanup(pool: &MySqlPool) {
    loop {
        tokio::time::sleep(Duration::from_secs(60)).await;

        // 1. 期限切れLease削除
        cleanup_expired_leases(pool).await;

        // 2. 古いメトリクス削除（24時間以上）
        cleanup_old_metrics(pool).await;

        // 3. サムネキャッシュLRU
        cleanup_thumbnail_cache().await;

        // 4. 切断WebSocket検出
        cleanup_stale_connections().await;
    }
}
```

### 3.3 クライアント側メモリ管理

```javascript
// WeakMapで参照を保持し、GC対象になりやすくする
const eventDataMap = new WeakMap();

// Image/Videoのsrc解放
function releaseMedia(element) {
    if (element instanceof HTMLVideoElement) {
        element.pause();
        element.srcObject = null;
        element.src = '';
        element.load();
    } else if (element instanceof HTMLImageElement) {
        element.src = '';
    }
}
```

---

## 4. WebRTCクリーンアップ

### 4.1 必須クリーンアップ手順

```javascript
class StreamManager {
    constructor() {
        this.peerConnection = null;
        this.mediaStream = null;
        this.videoElement = null;
    }

    async connect(streamUrl) {
        this.peerConnection = new RTCPeerConnection();
        // ... 接続処理
    }

    cleanup() {
        // 1. トラック停止
        if (this.mediaStream) {
            this.mediaStream.getTracks().forEach(track => {
                track.stop();
            });
            this.mediaStream = null;
        }

        // 2. Video要素のsrcObject解除
        if (this.videoElement) {
            this.videoElement.srcObject = null;
            this.videoElement.src = '';
            this.videoElement.load();
            this.videoElement = null;
        }

        // 3. PeerConnection close
        if (this.peerConnection) {
            this.peerConnection.close();
            this.peerConnection = null;
        }

        // 4. イベントリスナ解除（自動的に行われるが明示的に）
        // removeEventListener呼び出し
    }
}
```

### 4.2 HLS/Video要素クリーンアップ

```javascript
function cleanupHLSPlayer(hlsInstance, videoElement) {
    if (hlsInstance) {
        hlsInstance.destroy();
    }
    if (videoElement) {
        videoElement.pause();
        videoElement.src = '';
        videoElement.load();
        videoElement.removeAttribute('src');
    }
}
```

---

## 5. バックグラウンド制御

### 5.1 Page Visibility API

```javascript
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        // バックグラウンド時
        handleBackgroundState();
    } else {
        // フォアグラウンド復帰時
        handleForegroundState();
    }
});

function handleBackgroundState() {
    // 1. モーダル停止
    if (activeModal) {
        activeModal.cleanup();
        releaseModalLease();
        activeModal = null;
    }

    // 2. サジェストは設定による（既定: 継続）
    if (config.stopSuggestOnBackground) {
        suggestPlayer.pause();
    }

    // 3. WebSocket維持（Heartbeat継続）
}

function handleForegroundState() {
    // 1. サジェスト復帰
    if (config.stopSuggestOnBackground) {
        suggestPlayer.play();
    }

    // 2. 状態同期（最新のGlobalSuggestState取得）
    syncSuggestState();
}
```

### 5.2 アイドル検出

```javascript
let idleTimeout;
const IDLE_THRESHOLD_MS = 5 * 60 * 1000; // 5分

function resetIdleTimer() {
    clearTimeout(idleTimeout);
    idleTimeout = setTimeout(handleIdle, IDLE_THRESHOLD_MS);
}

function handleIdle() {
    // アイドル状態
    // 1. モーダル自動解放
    if (activeModal) {
        activeModal.cleanup();
        releaseModalLease();
        activeModal = null;
    }
    // 2. サジェストは継続
}

// ユーザー操作で復帰
['mousemove', 'keydown', 'click', 'scroll', 'touchstart'].forEach(event => {
    document.addEventListener(event, resetIdleTimer, { passive: true });
});
```

---

## 6. 計画リフレッシュ

### 6.1 目的

キオスク的な運用での予防的リフレッシュ。

### 6.2 実装

```javascript
// 運用設定
const REFRESH_INTERVAL_HOURS = 24;
const REFRESH_TIME = '03:00'; // 深夜3時

function scheduleRefresh() {
    const now = new Date();
    const [hours, minutes] = REFRESH_TIME.split(':').map(Number);

    let refreshTime = new Date();
    refreshTime.setHours(hours, minutes, 0, 0);

    if (refreshTime <= now) {
        refreshTime.setDate(refreshTime.getDate() + 1);
    }

    const delay = refreshTime - now;
    setTimeout(() => {
        location.reload();
    }, delay);
}
```

### 6.3 サーバー側リスタート

```bash
# /etc/systemd/system/camserver-refresh.timer
[Unit]
Description=Camserver daily refresh

[Timer]
OnCalendar=*-*-* 03:00:00
Persistent=true

[Install]
WantedBy=timers.target
```

```bash
# /etc/systemd/system/camserver-refresh.service
[Unit]
Description=Restart Camserver

[Service]
Type=oneshot
ExecStart=/bin/systemctl restart camserver.service
```

---

## 7. 監視・アラート

### 7.1 メモリ監視

```rust
async fn monitor_memory() {
    loop {
        tokio::time::sleep(Duration::from_secs(60)).await;

        let sys = System::new_all();
        let used_memory = sys.used_memory();
        let total_memory = sys.total_memory();
        let usage_percent = (used_memory as f64 / total_memory as f64) * 100.0;

        // メトリクス記録
        record_metric("memory_usage_percent", usage_percent).await;

        // アラート
        if usage_percent > 90.0 {
            alert("CRITICAL: Memory usage > 90%").await;
        } else if usage_percent > 80.0 {
            warn("WARNING: Memory usage > 80%");
        }
    }
}
```

### 7.2 接続数監視

```rust
async fn monitor_connections() {
    loop {
        tokio::time::sleep(Duration::from_secs(30)).await;

        let ws_count = websocket_hub.connection_count();
        let modal_count = lease_manager.active_count();
        let suggest_viewers = suggest_engine.viewer_count();

        // メトリクス記録
        record_metric("websocket_connections", ws_count).await;
        record_metric("active_modals", modal_count).await;
        record_metric("suggest_viewers", suggest_viewers).await;
    }
}
```

### 7.3 Soak Test指標

| 指標 | 閾値 | 対応 |
|-----|------|------|
| メモリ増加率 | < 1MB/時 | 許容 |
| メモリ増加率 | > 10MB/時 | 要調査 |
| 接続数推移 | 安定 | 正常 |
| 接続数推移 | 単調増加 | リーク疑い |
| イベントログ件数 | 上限以下 | 正常 |
| Lease数 | 上限以下 | 正常 |

---

## 8. データベースメンテナンス

### 8.1 定期削除

```sql
-- 14日以上古いno_eventフレーム削除
DELETE FROM frames
WHERE detected = 0
  AND captured_at < DATE_SUB(NOW(), INTERVAL 14 DAY)
LIMIT 10000;

-- 30日以上古い通知履歴削除
DELETE FROM notifications
WHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY)
LIMIT 10000;

-- 7日以上古いメトリクス削除
DELETE FROM admission_metrics
WHERE recorded_at < DATE_SUB(NOW(), INTERVAL 7 DAY)
LIMIT 10000;
```

### 8.2 バッチスケジュール

```bash
# /etc/cron.d/camserver-maintenance
# 毎日4時に実行
0 4 * * * camserver /opt/camserver/scripts/db_cleanup.sh
```

---

## 9. 障害復旧

### 9.1 自動復旧

| 状況 | 対応 |
|-----|------|
| WebSocket切断 | 自動再接続（指数バックオフ） |
| API一時エラー | リトライ（3回） |
| サジェストストリーム切断 | 自動再接続 |
| モーダルストリーム切断 | ユーザーに再接続ボタン表示 |

### 9.2 再接続ロジック

```javascript
class ReconnectManager {
    constructor() {
        this.attempts = 0;
        this.maxAttempts = 5;
        this.baseDelay = 1000; // 1秒
    }

    async reconnect(connectFn) {
        while (this.attempts < this.maxAttempts) {
            try {
                await connectFn();
                this.attempts = 0; // 成功したらリセット
                return;
            } catch (e) {
                this.attempts++;
                const delay = this.baseDelay * Math.pow(2, this.attempts);
                await sleep(delay);
            }
        }
        // 最大試行回数超過
        showErrorMessage('接続に失敗しました。ページをリロードしてください。');
    }
}
```

---

## 10. テスト観点

### 10.1 長時間運用（Soak Test）

- [ ] 24時間連続運用でメモリリークなし
- [ ] 72時間連続運用でパフォーマンス劣化なし
- [ ] イベントログが上限を超えない
- [ ] Lease蓄積なし

### 10.2 リソースクリーンアップ

- [ ] モーダル開閉100回でメモリ増加なし
- [ ] サジェスト切替100回でメモリ増加なし
- [ ] WebSocket切断/再接続でリソースリーク無し

### 10.3 バックグラウンド

- [ ] バックグラウンド時にモーダル停止
- [ ] フォアグラウンド復帰時にサジェスト同期
- [ ] アイドル検出でモーダル解放

### 10.4 障害復旧

- [ ] WebSocket自動再接続
- [ ] API一時エラー後の復旧
- [ ] ストリーム切断後の復旧

---

## 更新履歴

| 日付 | バージョン | 内容 |
|-----|-----------|------|
| 2025-12-31 | 1.0 | 初版作成（Phase 4） |
