# is22 Camserver 仕様案（基本設計書 草案）

**ページタイトル：mobes AIcam control Tower (mAcT)**  
**UI：araneaDevice IS20 準拠 / shadcn/ui 準拠（Reactベース・MUI系のミニマル指向）**

---

## 0. 文書情報（SSoT）

- 文書名：is22 Camserver 仕様案（基本設計書 草案）
    
- バージョン：0.1-draft
    
- 対象：is22（Linuxサーバー）上で稼働する Camserver（監視・可視化・提案表示・配信・スキャン）
    
- 関連：
    
    - is21：AI_imageProseser（既存実装が進行中、連携方式は現行実装を確認し調整）
        
    - is20：UI準拠規格（araneaDevice IS20）
        
- 前提利用環境：
    
    - LAN内またはVPNサブネット内に限定（インターネット公開しない）
        
    - 最大カメラ台数：~30台
        
    - UI同時アクセス：最大10（+安全値マージンあり）
        
    - 視聴：サジェスト（共通）＋モーダル（個別・短時間）
        

---

## 1. 目的・ゴール（MECE）

### 1.1 目的

is22 Camserver は、施設内の状態を「常時可視化」するために、以下を統合的に提供する。

1. カメラ画像の巡回取得（軽量）
    
2. is21 AI_imageProseser への同期的な推論依頼（取りこぼし許容）
    
3. 検知ログ（イベント）を高頻度でストリーム配信（重要）
    
4. 「サジェスト再生」（全ユーザー共通のライブ表示）
    
5. ユーザーの任意操作による「モーダル拡大」（混雑時は拒否できる）
    
6. カメラ候補機器の探索（IpcamScan）とインベントリ補助
    

### 1.2 ゴール（品質・運用）

- **長時間表示運用でパンクしない**（リーク/積み残しがあっても自動回復する設計）
    
- **全体UX最優先**：巡回・ログ・サジェストを死守し、モーダルは混雑時に拒否してよい
    
- **アンアンビギュアス**：状態・責務・入出力・上限制御を明確に定義する
    
- **SSoT**：カメラ情報・状態・イベントログ等の真実の源泉を一意にする
    
- **SOLID**：コンポーネント分離（拡張容易・差し替え可能・責務単一）
    

### 1.3 非ゴール（Out of Scope）

- 防犯用途の「取りこぼしゼロ」「証跡完全性（法的要件）」は目的にしない
    
- カメラ認証情報の推測・総当たり（ブルートフォース）は実装しない
    
- is21 の内部仕様の固定化（既存実装を確認して調整が必要）
    
- ルータ/管理コントローラ固有（Omada等）への強依存は必須としない（補助情報としては活用余地）
    

---

## 2. 用語定義（SSoT）

- **Camserver**：is22上で稼働する統合サーバー（本書の対象）
    
- **サジェスト再生**：検知イベント等を根拠に「今見るべきカメラ」を左ペインにライブ表示する仕組み（全ユーザー共通）
    
- **モーダル再生**：ユーザーが任意のカメラを拡大表示するための一時的なライブ表示（個別・時間制限あり）
    
- **巡回（Polling）**：カメラのサブストリーム等から静止画を順次取得し、is21へ推論依頼する同期処理
    
- **イベントログ**：検知結果を「時系列ストリーム」として蓄積/配信するログ（右ペインの主役）
    
- **lacisID / lacisOath**：is21連携に用いる認証識別（詳細は既存実装を確認し調整）
    
- **cic（ClientIdentyCode）**：mobesSystem発行のクライアント識別コード（詳細は既存実装を確認し調整）
    
- **IpcamScan**：指定サブネットからIPカメラ候補を段階的エビデンスで絞り込み、メーカー/機種推定まで行う機能（is22に実装）
    

---

## 3. 全体像（アーキテクチャ概要）

### 3.1 コンテキスト（境界）

- is22 Camserver は、以下の外部と連携する：
    
    - **IPカメラ群**（例：TP-Link Tapo：stream1/stream2 等）
        
    - **is21 AI_imageProseser**（推論API。認証は lacisID + cic 等、要検証）
        
    - **UIクライアント（ブラウザ）**（LAN/VPN内からアクセス）
        
    - **（任意）MQTT**（オンライン設定変更・通知の経路として将来検討。方式は固定しない）
        

### 3.2 主要コンポーネント（SOLID）

is22 内部は以下の責務に分割する（依存は原則「インターフェース」に向ける）。

1. **ConfigStore（SSoT）**
    
    - カメラ台帳、ネットワーク設定、上限/閾値、認証設定（参照のみ）を保持
        
2. **SnapshotService**
    
    - カメラから静止画取得（主にサブストリーム/低負荷）
        
3. **AIClient（is21 Adapter）**
    
    - 推論依頼/結果受領（lacisID/cic 認証、コンテキスト付与などは「要検証」）
        
4. **PollingOrchestrator**
    
    - 1台ずつ同期で巡回（バックプレッシャーを自然に確保）
        
5. **EventLogService**
    
    - イベントを append-only で蓄積・配信（リングバッファ設計）
        
6. **SuggestEngine**
    
    - 検知結果からサジェスト再生対象を決定（ポリシーは設定で変更可能）
        
7. **StreamGatewayAdapter**
    
    - ブラウザ再生用配信（WebRTC/HLS等）を提供するゲートウェイへの接続・状態取得
        
    - 参照実装候補：go2rtc 等（ただし差し替え可能にする）
        
8. **AdmissionController**
    
    - CPU/メモリ圧＋固定枠の“予算”に基づきモーダル許可/拒否
        
9. **RealtimeHub**
    
    - WebSocket/SSE による状態配信（ログ・サジェスト状態・カメラ状態）
        
10. **WebAPI**
    

- REST API（設定/状態/操作/スキャン等）
    

11. **IpcamScan**
    

- サブネット探索ジョブ（本書後半に詳細）
    

---

## 4. UI仕様（araneaDevice IS20準拠 / shadcn/ui）

### 4.1 UI方針

- React + shadcn/ui ベース（MUI系のミニマルUI規約に準拠）
    
- **ページタイトル**：`mobes AIcam control Tower (mAcT)`
    
- 状態表示は「軽く・少ないDOM更新」で長時間運用に耐える
    
- UIは基本的に **サーバー主導（全ユーザー共通のサジェスト表示・ログ）**  
    ※モーダルのみユーザー任意（個別）
    

### 4.2 画面レイアウト（3ペイン）

- 左ペイン（やや大きい）：
    
    - **サジェストライブ動画**
        
    - 検知イベントがない時は「空（何もなし）」または控えめプレースホルダ
        
- 中央ペイン：
    
    - カメラサムネ羅列（豆サムネ）＋カメラ名＋メタ情報
        
    - ライブ中（サジェスト対象）カメラのサムネ外周をハイライト
        
- 右ペイン：
    
    - AI解析ログ（時系列でストリーミング表示）
        
    - ログは「最新N件のみ保持（リングバッファ）」で無限増加を禁止
        

### 4.3 インタラクション

- サムネクリック：
    
    - モーダルを開く（ユーザー個別）
        
    - **モーダルは複数同時再生をしない**（同一ユーザーにつき最大1）
        
- モーダル内：
    
    - 標準：中画質（サブ相当）で即時表示
        
    - 任意：HD（メイン相当）ボタン（ただし AdmissionController が許可した場合のみ）
        
- 混雑/過負荷時：
    
    - モーダル要求を拒否し、メッセージ表示  
        例：「現在多数のアクセスがありストリーム数が上限に達しています。しばらく経ってからアクセスしてください」
        

### 4.4 長時間運用向けUI要件

- ログ表示：最新N件のみ（例：500件）
    
- バックグラウンド時：
    
    - モーダルは即停止（推奨）
        
    - サジェストは運用方針で継続/停止を選べる（既定：継続）
        
- 再生要素は必ずクリーンアップ（WebRTC PeerConnection close / track stop）
    

---

## 5. 主要機能仕様（is22 Camserver）

## 5.1 カメラ台帳（Camera Inventory：SSoT）

### 5.1.1 目的

- 巡回・ログ・サジェスト・配信・スキャン結果を統合する唯一の真実（SSoT）
    

### 5.1.2 Cameraモデル（例）

- `cameraId`（不変ID、SSoTキー）
    
- `displayName`
    
- `enabled`（true/false）
    
- `location`（任意）
    
- `tags`（任意）
    
- `vendorHint`（任意：Tapo/VIGI/Nest/Other）
    
- `ipAddress` / `subnetId`
    
- `streamProfiles`：
    
    - `mainRtspUrl`（例：…/stream1）
        
    - `subRtspUrl`（例：…/stream2）
        
    - `thumbSource`（sub or dedicated snapshot）
        
- `aiContextHint`（is21へ渡す補助情報）
    
    - 例：「部屋の写真である」「監視対象にドアが含まれる」等  
        ※is21側仕様は現行実装を確認してアジャストが必要（本書で固定しない）
        
- `suggestPolicyWeight`（優先度調整用）
    
- `createdAt` / `updatedAt`
    

### 5.1.3 SSoTルール

- 台帳の正本：ConfigStore（DB）
    
- 生成物（派生）：
    
    - サムネキャッシュ：派生（消しても復旧可能）
        
    - ストリームゲートウェイ設定：派生（DBから生成）
        
    - UI表示状態：派生（DB＋イベントから復元可能）
        

---

## 5.2 巡回（Polling）とAI推論連携

### 5.2.1 方針

- 「取りこぼし許容」「同期処理優先」
    
- 巡回が推論処理より速くならない（バックプレッシャー）
    
- 1台ずつ順に処理する（単一ワーカーを基本）
    

### 5.2.2 巡回周期の目標

- **1周1分未満**なら実用範囲
    
- 30台・1件あたり推論 200〜500ms の場合、推論だけで 6〜15秒 + 取得時間
    
- 実運用ではネットワーク/取得待ち/ログ処理を含み、概ね数十秒〜1分を許容範囲とする
    

### 5.2.3 巡回フロー（アンアンビギュアス）

各 `cameraId` について以下を順に実行する。

1. **スナップショット取得**
    
    - 取得元：基本 `subRtspUrl`（負荷低減）
        
    - タイムアウト：設定値（例：0.5〜1.0秒）
        
    - 失敗時：
        
        - `SnapshotFailed` をログへ記録
            
        - 当該カメラは今回スキップして次へ（巡回停止しない）
            
2. **is21へ推論依頼（同期）**
    
    - 入力：画像（または画像URL）＋ cameraId ＋ aiContextHint（任意）
        
    - 認証：lacisID（lacisOath）＋ cic（mobesSystem発行）  
        ※方式・トークン形式・更新手順は is21 実装を確認して要調整
        
    - 応答：推論結果（検知物、数、属性、スコア等）  
        ※スキーマは is21 実装に合わせる（本書で固定しない）
        
3. **結果の正規化（Normalization）**
    
    - is22内部の共通イベント形式に変換
        
    - 例：`DetectionEvent`（後述）
        
4. **イベントログへ追記（append-only）**
    
    - 常に行う（検知が「無」でも必要に応じて簡易ログを残すかは設定）
        
    - 右ペインのストリームに流す
        
5. **サジェスト判定（必要時のみ）**
    
    - 重大度/優先度（設定）によりサジェスト対象を決定
        
    - 「やべーぞ固定表示」等の運用はポリシー設定で対応
        
6. 次のカメラへ
    

### 5.2.4 is21連携に関する注意（指定しすぎない）

- 認証（lacisID/cic）やMQTTによるオンライン設定変更は「実装・運用を検証しないとダメ」  
    → is22側は **“差し替え/拡張可能なAdapter”** として設計する
    
- is21の「シーン情報（部屋/ドア等）を受け渡して精度向上」機能は有用  
    → is22側は camera.aiContextHint を持ち、is21実装に合わせて送れるようにする  
    → ただし is21側が既に実装進行中のため **現行実装を確認してアジャストが必要**
    

---

## 5.3 イベントログ（右ペイン主役）

### 5.3.1 要件

- 常時更新され続ける
    
- 長時間運用でパンクしない（無限蓄積・無限DOM禁止）
    

### 5.3.2 イベント形式（例：内部共通）

`DetectionEvent`（正規化後）

- `eventId`（一意）
    
- `ts`（イベント時刻）
    
- `cameraId`
    
- `summary`（例：「検出！19:20 カメラA 人×2 赤い服」）
    
- `severity`（0..100 など）
    
- `labels`（例：person, red_clothes）
    
- `counts`（例：{person: 2}）
    
- `attributes`（任意：色、領域、ドア付近等）
    
- `snapshotRef`（サムネ参照：ファイル/キー）
    
- `rawRef`（必要ならis21生データ参照）
    

### 5.3.3 保存（SSoT）

- 正本：EventLogStore（DB or ログストレージ）
    
- UI配信用：最新N件のリングバッファ（メモリ）
    
    - Nは設定（例：2000）
        
    - UI側も保持上限（例：500）
        

---

## 5.4 サジェスト再生（左ペイン・全員共通）

### 5.4.1 要件

- サジェスト対象はサーバーで決定し、全ユーザーに同じ状態を配信
    
- ただし映像自体の配信は各クライアントが受ける（“状態共有”）  
    → サーバーが映像を再配信して統一する必要はない
    

### 5.4.2 サジェスト状態（GlobalSuggestState）

- `active`（true/false）
    
- `cameraId`
    
- `streamProfile`（原則：sub）
    
- `reasonEventId`
    
- `startedAt`
    
- `expiresAt`（無限にしない。設定されたTTLで見直す）
    
- `policy`（どのルールで選ばれたかの識別子）
    

### 5.4.3 切替ポリシー（設定で変更可能）

- 優先度（severity、特定ラベル、人検出等）でスコアリング
    
- 「固定貼り付け（sticky）」の条件（例：特定ラベル/閾値超え）を設定可能
    
- 多発時：
    
    - サジェストは「最優先1件」に集約（左ペインは1枠のみ）
        
    - 他はログで流す／中央でハイライトする
        

### 5.4.4 “速く見せる”ためのプリウォーム（任意）

- サジェスト切替時に StreamGatewayAdapter を使って短時間の事前接続を行う（プリウォーム）
    
- 方式はゲートウェイ実装依存（本書は「プリウォーム可能な設計」を要求）
    

---

## 5.5 モーダル再生（個別・短時間）

### 5.5.1 基本方針

- モーダルは**表示しっぱなし用途ではない**
    
- 一定時間でストリーム停止し、再接続を求める（妥当）
    
- 同一ユーザー：モーダルは同時に1つのみ（負荷抑制）
    

### 5.5.2 モーダルのTTL（ハード制限）

- 既定：`MODAL_TTL_SEC`（例：180〜300秒、設定可能）
    
- TTL到達時：
    
    - ストリーム停止
        
    - UIは「再接続」ボタンとメッセージ表示
        
- 延長：
    
    - 再接続操作は明示的（自動再接続は行わない）
        
    - 再接続時にAdmission判定を再実施
        

### 5.5.3 画質方針（負荷とUXのバランス）

- 初期：sub（中画質）で即表示
    
- HD要求：mainに切替（ただし許可時のみ）
    
- 混雑時はHD不可・またはモーダル不可
    

---

## 5.6 負荷制御（Admission Control / Resource Governance）

### 5.6.1 目的

- “通常巡回・サジェスト・操作パフォーマンス感”を最優先で死守
    
- モーダルは拒否して良い（メッセージ表示で割り切る）
    

### 5.6.2 予算モデル（SSoT的に一元管理）

- まず上限を固定し、安全マージンを含めた「予算」を設ける
    
    - `MAX_UI_USERS`（例：10 + safety）
        
    - `RESERVED_BASELINE_UNITS`（巡回・ログ等の予約）
        
    - `RESERVED_SUGGEST_UNITS = MAX_UI_USERS * 1`（サジェストが出ている場合の最悪ケース）
        
    - `TOTAL_STREAM_UNITS`（機器能力に合わせて設定）
        
- モーダル許容量は  
    `MODAL_BUDGET = TOTAL_STREAM_UNITS - RESERVED_BASELINE_UNITS - RESERVED_SUGGEST_UNITS`
    

※「unit」の定義は設定で調整可能（例：sub=1, main=2）

### 5.6.3 CPU/メモリ圧（最終安全弁）

- 予算モデルに加えて、CPU使用率＋メモリプレッシャー（＋swap等）で強制的に制限を強める
    
- 過負荷時：
    
    - モーダルは拒否
        
    - 既存モーダルもTTLで自然終了
        
- “復帰条件”は厳しめにしてフラップを防ぐ（ヒステリシス）
    

### 5.6.4 UIメッセージ（仕様）

Admissionが拒否の場合、モーダルを開かずに以下を表示：

- 「現在多数のアクセスがありストリーム数が上限に達しています。しばらく経ってからアクセスしてください」
    

---

## 5.7 長時間運用でパンクしない設計（必須）

### 5.7.1 リース（Lease）＋Heartbeat（SSoT的にサーバーで管理）

- モーダル再生の許可は `ModalLease` としてサーバーが発行
    
- leaseはTTLで必ず失効（タブ放置・切断・閉じ忘れを回収）
    
- クライアントは一定周期で heartbeat を送る（例：15〜30秒）
    
- heartbeat停止で lease自動回収
    

### 5.7.2 UI側の後始末（必須）

- WebRTC/再生を停止する際、必ず
    
    - PeerConnection close
        
    - track stop
        
    - srcObject解除
        
    - イベントリスナ解除
        
- 背景タブ/非表示時：
    
    - モーダルは即停止（推奨）
        

### 5.7.3 ログ・DOMの無限増加禁止

- サーバー：最新N件リングバッファ
    
- クライアント：最新M件のみ保持
    
- 古いログは破棄（必要なら別画面で検索/履歴表示を実装）
    

### 5.7.4 計画リフレッシュ（任意・運用）

- キオスク的な運用では、日次/週次でのページリロードやサービス再起動を許容設計として残す  
    （本番の方針により採用/不採用を決める）
    

---

## 6. データ設計（SSoT）

### 6.1 ストア分類（真実の源泉）

- **ConfigStore（SSoT）**：
    
    - CameraInventory（カメラ台帳）
        
    - PolicyConfig（優先度/閾値/TTL/予算）
        
    - NetworkConfig（許可CIDR、IpcamScan対象）
        
- **EventLogStore（SSoT）**：
    
    - DetectionEvent（正規化イベント）
        
- **ScanStore（SSoT）**：
    
    - IpcamScanJob / Device / Evidence
        
- **Ephemeral（派生・消えても復元可能）**：
    
    - ThumbnailCache
        
    - GlobalSuggestState（復元可能なら永続化不要）
        
    - ModalLease（短命）
        

### 6.2 テーブル/オブジェクト例（要調整）

- `cameras`
    
- `policy_config`
    
- `events`
    
- `thumb_cache`
    
- `modal_leases`
    
- `ipcamscan_jobs`
    
- `ipcamscan_devices`
    
- `ipcamscan_evidence`
    

---

## 7. API設計（例・アンアンビギュアス）

### 7.1 UI向け（REST）

- `GET /api/cameras`：カメラ一覧（台帳＋状態）
    
- `GET /api/thumbs/{cameraId}.jpg`：豆サムネ（キャッシュ）
    
- `GET /api/suggest`：GlobalSuggestState
    
- `GET /api/system/status`：負荷状態（UI表示用は簡略で良い）
    

### 7.2 モーダル（Lease）

- `POST /api/modal/lease`：モーダル利用申請
    
    - req：`{cameraId, quality: "sub"|"main"}`
        
    - res（許可）：`{leaseId, expiresAt, allowedQuality}`
        
    - res（拒否）：`{errorCode:"OVER_CAPACITY", message:"…"}`
        
- `POST /api/modal/lease/{leaseId}/heartbeat`
    
- `DELETE /api/modal/lease/{leaseId}`
    

### 7.3 Realtime（WebSocket/SSE）

- `/ws/events`：イベントログ（append）
    
- `/ws/state`：GlobalSuggestState、カメラ状態、運用状態（必要最小）
    
- `/ws/health`：軽量な生存確認（任意）
    

---

# 8. is22 IpcamScan（機能仕様・検証観点統合）

> ※以下はユーザー提示の「IpcamScan機能に関する検証」仕様を、is22 Camserver の基本設計に統合したもの。  
> Camserver本体とは責務分離し、**IpcamScanモジュール**として独立実装する（SOLID：単一責務・依存逆転）。

## 8.1 目的

- 指定サブネット内から IPカメラ候補を効率的に絞り込み、最終的にメーカー/機種（例：Tapo/VIGI/Nest系）を特定するための実装仕様・検証観点を定義する。
    
- ブルートフォースを避け、段階的エビデンスを積み上げる。
    
- VPN越し（L3）でMACが取れないケースでも破綻しない。
    

## 8.2 スコープ

### In Scope

- ジョブ実行（手動/定期/外部トリガー）
    
- サブネット指定スキャン
    
- エビデンス蓄積、スコアリング、確証フェーズ
    
- ONVIF/RTSP/HTTP(S)/mDNS/SSDP等（可能な範囲）
    
- 正規クレデンシャルによる最終確認（必要最小限）
    
- 結果保存・差分検出・API提供
    

### Out of Scope

- ArpScannerデバイス（is10D/IS20s）の内部仕様固定（連携検討に留める）
    
- ルータ固有機能（Omada等）への必須依存
    
- 認証情報の推測・総当たり
    

## 8.3 前提・制約

- L2外（VPN等）ではMAC取得不能を前提に `mac=null` を許容
    
- mDNS/SSDP/WS-Discoveryはネットワーク制約で不安定になり得る
    
- スキャンは許可されたCIDRのみ（ホワイトリスト推奨）
    
- ログイン試行は正規アカウントのみ、失敗回数上限あり
    

## 8.4 システム構成（概念）

- is22 IpcamScan（ジョブ管理、実行、保存、API）
    
- （任意）現地エージェント（L2依存観測：ARP/mDNS/SSDP）
    
- （任意）ArpScanner（外部ソースとして取り込み）
    

## 8.5 多段エビデンス方式（Stage 0〜6）

### Stage 0：準備

- CIDR正規化、重複排除、除外設定
    
- 既存DB（過去結果）から優先候補抽出
    

### Stage 1：Host Discovery

- 既存インベントリ/外部ソース → ICMP → TCP軽量到達確認（優先順）
    
- 存在しないIPを落として負荷削減
    

### Stage 2：MAC/OUI（取得できるなら）

- 取得可：ベンダ推定（粗く）
    
- 取得不可：`mac=null`のまま継続（後段で補う）
    

### Stage 3：ポート指紋（最小セット）

- 例：RTSP 554、管理UI 80/443、ONVIF関連（環境で調整）
    
- open/closed/filtered を保存
    

### Stage 4：ディスカバリ（可能な範囲）

- WS-Discovery（UDP 3702）
    
- SSDP（UDP 1900）
    
- mDNS（UDP 5353）
    
- 取得できない場合でもエラーにしない（blocked/unsupportedとして記録）
    

### Stage 5：スコアリング

- エビデンスを点数化し上位候補のみをDeep確認へ
    
- 重みは設定可能（後から調整）
    

### Stage 6：確証（正規クレデンシャル）

- 対象：Stage5で絞った候補のみ
    
- ONVIF情報取得、RTSP疎通確認（最小）
    
- 失敗：試行上限・クールダウンで安全に
    

## 8.6 データモデル（保存最小セット）

### Job

- `job_id`, `requested_by`, `targets(CIDR[])`, `mode`, `ports`, `timeouts`, `rate_limit`, `concurrency`
    
- `started_at`, `ended_at`, `status(queued/running/partial/success/failed/canceled)`
    
- `summary`
    

### Device（インベントリ）

- `device_id`, `ip`, `subnet`, `mac(nullable)`, `oui_vendor(nullable)`
    
- `hostnames`, `open_ports`, `discovery(onvif/ssdp/mdns)`
    
- `identity(manufacturer/model/firmware/family/confidence)`
    
- `first_seen`, `last_seen`, `evidence_refs`
    

### Evidence

- `evidence_id`, `type`, `raw(summary/masked)`, `ts`, `source`
    

## 8.7 API（例）

- `POST /api/ipcamscan/jobs`
    
- `GET /api/ipcamscan/jobs/{job_id}`
    
- `GET /api/ipcamscan/devices?...`
    
- `POST /api/ipcamscan/devices/{device_id}/verify`
    

## 8.8 Camserverとの統合ポイント（SSoT）

- IpcamScanの「確証済みデバイス」は、CameraInventory（SSoT）に取り込む候補になり得る
    
- ただし誤検出を考慮し、**自動登録はせず**「承認フロー（管理者が採用）」を推奨
    

---

## 9. セキュリティ・安全設計（MECE）

1. ネットワーク制限：LAN/VPN内、許可CIDRのみ
    
2. 認証情報：平文保存しない（秘匿ストア）、監査ログ、マスキング
    
3. 失敗制御：リトライ上限、クールダウン、ジョブ上限
    
4. ブルートフォース禁止
    
5. ログ：機微情報を残さない（トークン/パスワードのマスク）
    
6. UIアクセス：必要に応じて認証導入（運用で決定）
    

---

## 10. 性能・負荷設計（目安）

- 巡回：同期1ワーカー、タイムアウト短め、失敗でスキップ
    
- サジェスト：全ユーザー共通状態だが、映像送出はクライアントごと（同接分）
    
- モーダル：短TTL＋Admissionで拒否可能
    
- 長時間運用：
    
    - リース回収
        
    - ログリングバッファ
        
    - UIバックグラウンド制御
        

---

## 11. 検証計画（受入観点）

### 11.1 Camserver（UI/巡回/ログ/サジェスト）

- 30台で1周1分未満になり得る（環境依存、実測記録）
    
- ログが継続更新され、DOMが増え続けない
    
- サジェストが優先され、過負荷時にモーダルが拒否される
    
- 長時間（例：24〜72時間）放置でもパンクしない（soak）
    

### 11.2 is21連携（要検証）

- lacisID/cic 認証が現行実装通りに動作するか
    
- contextHintの送受が精度/動作に寄与するか（現行実装確認）
    
- MQTTによるオンライン設定変更がある場合、is22側の追随が必要か（検証）
    

### 11.3 IpcamScan

- Stage別の検出率・blocked時の挙動・L2/L3差分・負荷/安全性
    
- 総当たりを行わずに候補抽出が破綻しない
    

---

## 12. 未決事項（TODO・リスク）

- is21 API仕様（認証・リクエスト/レスポンス・contextHint schema）の確定：**現行実装確認が必須**
    
- StreamGateway（go2rtc等）の採用/運用方式（自動生成・再読込・監視方法）
    
- Admissionの具体閾値（CPU/メモリ圧/総ストリーム数）…実測で調整
    
- イベントの「無」扱い（ログに残す/残さない）とログ量設計
    
- UIのアクセス制御方針（LAN前提でも要件次第）
    

---

## 付録：設計原則の適用（要点）

- **SOLID**
    
    - AI連携/配信ゲートウェイ/スキャン/ログ/巡回を分離し、差し替え可能なAdapter化
        
- **SSoT**
    
    - カメラ台帳・ポリシー・イベントログは必ず一意の正本を持つ
        
- **MECE**
    
    - 機能を「巡回/推論」「ログ」「サジェスト」「モーダル」「スキャン」「運用/負荷/セキュリティ」に分割
        
- **アンアンビギュアス**
    
    - 状態（GlobalSuggestState / ModalLease）、TTL、拒否メッセージ、上限算出方法を明示
        

---

# is22 IpcamScan機能に関する検証

## 1. 文書の目的

本書は、**is22（Linuxサーバー）に実装する IpcamScan 機能**について、  
「指定サブネット内から IPカメラ候補を効率的に絞り込み、最終的にメーカー/機種（例：Tapo/VIGI/Nest系）を特定する」ための **実装仕様**と **動作ロジックの検証観点**を整理する。

- 目標：
    
    - ブルートフォース等の非効率/高リスクな試行を避けつつ、段階的な証拠（エビデンス）を積み上げて対象を特定する。
        
    - **VPN越し（L3）等でMACが取れない場合でも**、最終的に候補抽出が破綻しない設計にする。
        
- 本書は「どの機器を使うべきか」のハードウェア選定ではなく、**is22側の機能実装と検証**を主眼とする。
    

---

## 2. 背景と課題

### 2.1 背景

- Tapo / VIGI などのIPカメラは、RTSP/ONVIF等のプロトコルや管理UIを持つことが多い。
    
- Google Nest系は、ローカルでONVIF/RTSPが常時開いていない場合があり、**mDNS/SSDP等のローカルディスカバリ**寄りで候補を拾う必要がある可能性がある。
    

### 2.2 課題（現状の痛点）

- 「サブネット内で ping 応答がある全IPに対し、カメラアカウントで接続を試行」すると、
    
    - 試行回数が多すぎて非効率
        
    - ログ/監視に引っかかる、失敗リトライで負荷が高い
        
    - パスワード違い/機種違いで徒労が大きい
        
- VPN越しなど **L3越し環境**では、MACが取得できず OUI判定が使えない。
    

---

## 3. スコープ

### 3.1 対象（In Scope）

- is22（Linuxサーバー）に搭載する IpcamScan 機能
    
    - ジョブ実行（手動/定期/外部トリガー）
        
    - サブネット指定スキャン
        
    - エビデンス蓄積による候補抽出・スコアリング
        
    - ONVIF/RTSP/HTTP(S)/mDNS/SSDP等の情報取得（可能な範囲）
        
    - 正規クレデンシャルによる最終確認（必要最小限）
        
    - 結果の保存・差分検出・API提供
        

### 3.2 対象外（Out of Scope）

- ArpScannerデバイス（is10D系 / IS20s系）の詳細仕様・実装
    
    - 本書では **「連携方法の検討」**に留め、デバイス内部の仕様は規定しない
        
- ルータ/コントローラ固有機能への依存（Omada等）
    
    - 追加の情報ソースとしては有益だが、本仕様の必須要件とはしない
        
- 認証情報の推測・総当たり（ブルートフォース）
    
    - 本機能で実装しない（セキュリティ/運用面の理由）
        

---

## 4. 前提・制約

### 4.1 ネットワーク制約

- **MAC（ARP/NDP）でのIP-MAC対応取得は原則 L2内のみ**
    
    - VPN越し等のL3環境では、MACが取得できないことを前提に設計する。
        
- mDNS/SSDP/WS-Discoveryは **マルチキャスト/ブロードキャスト制限**により不安定になり得る。
    
    - 施設Wi-Fi等ではクライアント分離（AP isolation）により、端末間が見えない場合がある。
        

### 4.2 運用制約（安全設計）

- スキャンは**管理者の許可があるネットワーク範囲でのみ**実行する。
    
- 接続試行（ONVIF/RTSP/HTTPログイン）は**正規に保有するアカウントのみ**を利用し、失敗回数に上限を設ける。
    

---

## 5. システム構成（概念）

### 5.1 コンポーネント

- **is22 IpcamScan（Linuxサーバー）**
    
    - ジョブ管理（スケジューラ/キュー）
        
    - スキャン実行（ローカル or リモートエージェント経由）
        
    - エビデンス保存、スコアリング、確証フェーズ
        
    - 結果API（UI連携/外部連携）
        
- **（任意）現地エージェント**
    
    - mDNS/SSDP/ARPなど “現地L2依存の観測” を担う
        
    - is22からの指示でアクティブスキャンを実行し結果を返す
        
- **（任意）ArpScannerデバイス（is10D系 / IS20s系）**
    
    - IP-MAC対応や存在情報を返す可能性がある外部ソース
        
    - is22は結果を取り込み、候補母集団として利用する（詳細は後述）
        

### 5.2 データフロー（概要）

1. is22がジョブを開始（サブネット、モード、パラメータ）
    
2. ローカル実行 or エージェントに実行指示
    
3. エビデンス収集（IP存在、MAC/OUI、ポート、ディスカバリ、確証情報）
    
4. スコアリングで候補を絞り込む
    
5. 必要最小限の認証付き確認を実施
    
6. 結果を保存・通知（API/DB/ログ）
    

---

## 6. 機能要件

### 6.1 ジョブ管理

- ジョブ作成（手動/API/定期）
    
- 入力パラメータ
    
    - 対象サブネット（CIDR複数可）
        
    - 実行モード（Discoveryのみ / Deep確認あり 等）
        
    - ポートセット（プリセット + 任意追加）
        
    - タイムアウト、並列度、レート制限
        
    - 認証情報セット（参照のみ・厳格に保護）
        
- ジョブ状態
    
    - queued / running / partial / success / failed / canceled
        
- 再実行・差分実行
    
    - 前回結果を参照し、変更がありそうなIPのみ深掘りできる
        

### 6.2 候補生成（Discovery）

- IP候補の生成優先度
    
    1. 既存インベントリ（過去結果）
        
    2. 外部ソース（ArpScanner連携、DHCP一覧等がある場合）
        
    3. ネットワーク探索（ICMP/TCP軽量スイープ）
        
- IP→MAC取得（可能な場合）
    
    - L2内：ARP/NDP等で取得
        
    - L3越し：取得不可として `mac=null` を許容（後段ロジックで吸収）
        

### 6.3 指紋取得（軽量ポートチェック）

- 対象：カメラで利用頻度が高いポートのみ（全ポート禁止が基本）
    
- 判定：open / closed / filtered（タイムアウト）
    
- 取得結果をエビデンスとして保存
    

### 6.4 ディスカバリプロトコル取得

- ONVIF WS-Discovery（可能な範囲）
    
- SSDP/UPnP（可能な範囲）
    
- mDNS（可能な範囲）
    
- 取得した文字列（サービス名、location、scopes等）を保存し、候補スコアに反映
    

### 6.5 確証取得（認証が必要な段階）

- スコア上位候補のみを対象にする
    
- 正規クレデンシャルのみ使用（推測・総当たり禁止）
    
- 取得目標（例）
    
    - メーカー/モデル
        
    - ファームウェア/シリアル（取得可能なら）
        
    - ONVIF profiles（解像度など）
        
    - RTSP URI（取得可能なら）
        
- RTSP疎通確認は「接続確認」レベルを基本とし、映像全取得は不要（負荷・用途外）
    

---

## 7. 動作ロジック（多段エビデンス方式）

is22 IpcamScan は以下の **Stage 0〜6** の段階を持つ。  
各ステージで得た証拠を蓄積し、スコアリングで次段の試行回数を最小化する。

### Stage 0: 実行前準備

- 入力CIDRを正規化（重複排除、例外除外）
    
- 既存DBから “既知カメラIP” を優先候補として取り出し（差分実行に活用）
    

### Stage 1: Host Discovery（存在確認）

- 実行優先順位（推奨）
    
    1. 外部ソース（ArpScanner/既存インベントリ）
        
    2. ICMP Echo（許可されていれば）
        
    3. TCP SYN/Connect（443/80等の軽量到達確認）
        
- ここで「存在しないIP」を落とし、以降の負荷を削減する
    

### Stage 2: MAC/OUI（取得できるなら強い証拠）

- 取得できた場合：
    
    - `mac`を保存し、OUIでベンダ推定（粗くてよい）
        
    - 例：「TP-Linkっぽい」「Google/Nestっぽい」など候補ラベル付け
        
- 取得できない場合：
    
    - `mac=null` のまま進め、後段のプロトコル/ポート証拠で補う
        

### Stage 3: ポート指紋（最小セット）

推奨プリセット（例）：

|目的|ポート例|
|---|---|
|RTSP|554/tcp（+必要なら 8554）|
|ONVIF|2020/tcp（+必要なら 80/443）|
|管理UI|80/tcp, 443/tcp（+必要なら 8080/8443）|

- open/closed/filtered を記録
    
- openポートの組み合わせから「カメラらしさ」をスコア化
    

### Stage 4: ディスカバリ（ONVIF/SSDP/mDNS）

- WS-Discovery（UDP 3702）
    
    - 応答あり：カメラ候補スコアを大幅加点（強い証拠）
        
- SSDP（UDP 1900）
    
    - 応答/広告の `location`/`server`/`st` 等を保存
        
- mDNS（UDP 5353）
    
    - `_services._dns-sd._udp` や既知サービスの存在、ホスト名等を保存
        

> 注意：ネットワーク制約で取得できない場合があるため、**Stage 4が失敗してもフローは継続**する。

### Stage 5: スコアリングと候補キュー生成

各IPに対して、エビデンスを点数化し **Deep確認対象（Stage 6）** を絞る。

- 例（概念）
    
    - +α：OUIがカメラ/対象メーカーに近い
        
    - +β：554 open
        
    - +γ：2020 open
        
    - +δ：WS-Discovery応答あり
        
    - +ε：SSDP/mDNSでカメラ類似の広告
        

出力：

- `candidate_ranked_list`（上位N件 or スコア閾値以上）
    

### Stage 6: 確証（正規クレデンシャルで最小試行）

- 対象：Stage5で絞った候補のみ
    
- 試行：
    
    - ONVIF（認証）→ device info / profiles / endpoints 等
        
    - RTSP（認証が必要なら）→ 最小疎通確認
        
- 失敗制御：
    
    - IPごとの試行回数上限
        
    - ジョブ全体の最大試行回数
        
    - “失敗した機器は一定時間スキップ” のクールダウン
        

結果：

- 成功：メーカー/モデル等を保存し **Tapo / VIGI / Nest系 / その他** を確定（または推定レベルを付与）
    
- 失敗：候補のまま残す（再試行は条件付き）
    

---

## 8. データモデル（保存するべき最小セット）

### 8.1 Job

- `job_id`
    
- `requested_by`
    
- `targets`（CIDR配列）
    
- `mode`（discovery / deep）
    
- `ports`（配列）
    
- `timeouts` / `rate_limit` / `concurrency`
    
- `started_at` / `ended_at` / `status`
    
- `summary`（発見数、確証数、失敗数など）
    

### 8.2 Device（インベントリ）

- `device_id`（内部ID）
    
- `ip` / `subnet`
    
- `mac`（nullable）
    
- `oui_vendor`（nullable）
    
- `hostnames`（mDNS/DHCP/逆引き等から得られた場合）
    
- `open_ports`（配列＋判定種別）
    
- `discovery`
    
    - `onvif`（xaddrs, scopes, last_seen）
        
    - `ssdp`（location, server, st, usn 等）
        
    - `mdns`（services, instance names 等）
        
- `identity`
    
    - `manufacturer` / `model` / `firmware`（取得できた範囲）
        
    - `family`（Tapo/VIGI/Nest/Other）
        
    - `confidence`（0〜100）
        
- `last_seen` / `first_seen`
    
- `evidence_refs`（生ログ/パケット要約への参照）
    

### 8.3 Evidence（証拠オブジェクト）

- `evidence_id`
    
- `type`（arp/portscan/wsd/ssdp/mdns/onvif_login 等）
    
- `raw`（全文は保存せず要約・必要なら暗号化/マスキング）
    
- `ts` / `source`（local/agent/is10D 等）
    

---

## 9. API・インタフェース（例）

### 9.1 is22 REST（例）

- `POST /api/ipcamscan/jobs`
    
- `GET /api/ipcamscan/jobs/{job_id}`
    
- `GET /api/ipcamscan/devices?subnet=...&family=...`
    
- `POST /api/ipcamscan/devices/{device_id}/verify`（深掘り再実行）
    

### 9.2 エージェント連携（任意）

- MQTT/HTTPS いずれでもよい（本書では方式固定しない）
    
- 最低限の要件：
    
    - `cmd`：ジョブID、対象CIDR、ポート、タイムアウト、レート制限
        
    - `result`：device配列（ip/mac/open_ports/discovery等）
        
    - `progress`：進捗/エラー
        

---

## 10. ArpScannerデバイス連携（検討事項のみ）

本件は所管外のため、**連携方式の検討に留める**。

### 10.1 連携目的

- is22側スキャンの前段として
    
    - **IP存在**（生存リスト）
        
    - **IP↔MAC対応**
        
    - （可能なら）簡易ベンダ情報  
        を受け取り、Stage1〜2の効率を上げる。
        

### 10.2 連携の最小インタフェース（案）

- 入力（is22→ArpScanner）：
    
    - 対象CIDR、ジョブID、実行指示（任意）
        
- 出力（ArpScanner→is22）：
    
    - `job_id`、`[{ip, mac, first_seen, last_seen}]` 程度の最小JSON
        

### 10.3 is22側の扱い

- “外部ソースの結果”として Evidence として保存
    
- is22のスキャン結果とマージ（MACが取れないL3環境の補助にはならない点に留意）
    

---

## 11. セキュリティ・安全設計

- **許可されたネットワーク範囲のみ**を対象とする（CIDRのホワイトリスト運用推奨）
    
- 認証情報の扱い
    
    - is22に平文保存しない（秘匿ストア利用、アクセス制御、監査ログ）
        
    - “候補絞り込み前にログインしない”
        
- **総当たり/推測を実装しない**
    
    - 失敗回数上限、クールダウン、ジョブ全体の上限
        
- レート制限
    
    - PPS/同時接続数を制御し、ネットワークや機器に負荷をかけない
        
- ログ
    
    - パスワード、トークン、個人情報になり得る値はマスキング
        

---

## 12. 性能・負荷設計（目安）

- /24スキャンを想定し、以下をパラメータ化して環境に合わせて調整可能にする
    
    - `concurrency`（同時接続数）
        
    - `timeout_ms`（TCP/Discovery/ONVIF）
        
    - `rate_limit_pps`（パケット/秒）
        
- 原則：
    
    - Stage1〜4は軽量に（短タイムアウト、少ポート）
        
    - Stage6は対象を絞って実施
        

---

## 13. エラーハンドリング方針

- ネットワーク制約で “できない” をエラーにしない
    
    - 例：MACが取れない、mDNSが見えない → `unsupported/blocked` として記録し継続
        
- 一時障害（タイムアウト）と恒久障害（拒否/未応答）を区別
    
- ジョブの結果は `partial_success` を許容（現場環境差が大きいため）
    

---

## 14. 検証計画（テスト観点）

### 14.1 機能検証

- Stage別の単体検証
    
    - Stage1：IP存在の検出率（ICMP不可環境でもTCPで拾えるか）
        
    - Stage2：MAC取得可否の判定が正しいか（L2/L3差）
        
    - Stage3：ポート判定（open/closed/filtered）が期待通りか
        
    - Stage4：WS-Discovery/SSDP/mDNSの取得とパース
        
    - Stage5：スコアリングが候補を適切に上位に寄せるか
        
    - Stage6：正規クレデンシャルで情報が取れる/取れない時の挙動
        

### 14.2 環境差分検証

- AP isolation 有/無
    
- ICMP遮断 有/無
    
- マルチキャスト制限 有/無
    
- VPN越し（L3）でMACが取れないケース
    

### 14.3 負荷/安全性検証

- /24での実行時間（目標値は環境依存なので記録ベース）
    
- PPS/同時接続を上げたときの機器への影響（ログ、遅延）
    
- 失敗回数上限・クールダウンが機能するか
    

### 14.4 受入基準（例）

- 指定サブネットに存在するカメラを、手動探索より高い効率で候補化できる
    
- 誤検出（カメラでない機器への深掘り試行）が許容範囲に収まる
    
- VPN越しでも「候補抽出（ポート/ディスカバリ証拠）」が破綻しない
    

---

## 15. 監視・ログ設計

- 監視指標（例）
    
    - job実行数、成功/失敗/partial
        
    - 発見デバイス数、確証デバイス数
        
    - スキャン時間、タイムアウト率、パケット送出量（推定）
        
- ログ
    
    - ジョブ単位の監査ログ（誰が、いつ、どこを、どのモードで実行）
        
    - 失敗理由の分類（timeout/blocked/refused/auth_failed など）
        
- エビデンスは “必要最小限” を保存し、再現性のための参照を残す
    

---

## 16. 今後の拡張（提案）

- 追加情報ソース統合（任意）
    
    - DHCPリース、DNS、スイッチ/ルータのクライアント情報等を “証拠” として統合
        
- Nest系の取り扱い強化
    
    - mDNS/SSDPの辞書強化、クラウドAPI連携（利用可能な場合）など
        
- ルールベース → 学習型のスコアリング（データが溜まった後）
    
    - 「この環境では2020が強い」「この環境ではSSDPが効く」など重みを自動調整
        

---

## 付録A：用語

- **L2/L3**：同一セグメント（L2）か、ルータ越し（L3）か
    
- **OUI**：MACアドレス先頭部から推定するベンダ識別子
    
- **RTSP**：カメラ映像配信で多用されるプロトコル（例：554/tcp）
    
- **ONVIF**：カメラ機器の標準仕様。Discovery/制御/情報取得など
    
- **WS-Discovery**：ONVIF等で使われる探索（主にUDP 3702）
    
- **mDNS/SSDP**：ローカルネットワークでのサービス発見
    

---

必要なら、この仕様をベースに「実装タスク分解（チケット粒度）」「APIの具体レスポンス例」「スコアリングの初期重み（暫定）」「検証用の擬似ネットワーク構成（テスト環境）」まで落として、開発にそのまま移せる形に整えます。