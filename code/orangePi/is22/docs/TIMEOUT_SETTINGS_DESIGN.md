# タイムアウト設定機能 設計ドキュメント

**作成日**: 2026-01-06
**対象システム**: is22 RTSP Camera Management Server
**関連Issue**: TBD（実装後に登録）

## 1. 概要

### 1.1 目的

125.0/24サブネットでのカメラエラー率上昇問題に対処するため、カメラのRTSPタイムアウト設定を柔軟に調整可能にする。

### 1.2 背景

**観測された問題**:
- 192.168.125.0/24サブネット: 平均5成功/3失敗（37.5%失敗率）
- 192.168.126.0/24サブネット: 平均9成功/0.01失敗（ほぼ100%成功）

**根本原因分析**:
1. **物理的な問題** (37.5%): 3台が完全ダウン (.13, .45, .79)
2. **タイムアウト不足** (25%): 2台が極端に遅い (.12: 2273ms RTT, .62: 1400ms RTT)
   - 現在のタイムアウト: Main 10秒、Sub 20秒
   - .62カメラ: Main(10s)でタイムアウト → Sub(20s)で成功 → 次サイクルでMain成功
3. **ネットワーク不安定** (12.5%): .78カメラで20%パケットロス

**解決策**:
- **提案1**: カメラ別カスタムタイムアウト（遅いカメラに個別設定）
- **提案2**: グローバルタイムアウト設定（全体のデフォルト値変更）
- カスタム設定がない場合はグローバル設定にフォールバック

### 1.3 適用範囲

- **対象モジュール**:
  - Database: `cameras`テーブル、`settings`テーブル
  - Backend: `snapshot_service`, `polling_orchestrator`, `web_api/routes`
  - Frontend: `SettingsModal.tsx`, `CameraDetailModal.tsx`

- **対象外**:
  - Go2RTC経由のスナップショット取得（既に別ロジック）
  - HTTPスナップショットURL（別のタイムアウト機構）

## 2. 機能要件

### 2.1 提案2: グローバルタイムアウト設定（優先実装）

#### 要件ID: GLOBAL-TIMEOUT-001
**要件**: システム全体のデフォルトタイムアウト値を設定可能にする

**受け入れ条件**:
- [ ] `settings.polling`に`timeout_main_sec`, `timeout_sub_sec`が保存される
- [ ] SettingsModalの「表示」タブに設定UI（入力欄2つ、保存ボタン）
- [ ] 入力範囲: 5秒～120秒
- [ ] 保存後、次回の巡回から新しい値が適用される
- [ ] カスタムタイムアウトが設定されていないカメラに適用される

**依存関係**:
- なし（独立して実装可能）

### 2.2 提案1: カメラ別カスタムタイムアウト設定

#### 要件ID: CUSTOM-TIMEOUT-001
**要件**: 各カメラに個別のタイムアウト値を設定可能にする

**受け入れ条件**:
- [ ] `cameras`テーブルに以下のカラム追加:
  - `custom_timeout_enabled` (TINYINT(1), DEFAULT 0)
  - `timeout_main_sec` (INT, NULLABLE)
  - `timeout_sub_sec` (INT, NULLABLE)
- [ ] CameraDetailModalにチェックボックス「カスタムタイムアウトを使用」
- [ ] チェック時、入力欄2つ（Main/Sub）が有効化
- [ ] 未チェック時はグローバル設定を使用
- [ ] 入力範囲: 5秒～120秒
- [ ] 保存後、次回の巡回から新しい値が適用される

**依存関係**:
- 提案2（グローバル設定）が先に実装されていること（フォールバック先として必要）

## 3. 非機能要件

### 3.1 パフォーマンス
- タイムアウト値の読み込みはキャッシュから行い、DB負荷を最小化
- ConfigStoreの既存キャッシュ機構を活用

### 3.2 互換性
- 既存カメラは自動的に`custom_timeout_enabled=0`でグローバル設定を使用
- マイグレーション時のダウンタイムなし

### 3.3 拡張性
- 将来的にHTTPスナップショットのタイムアウトも同様に拡張可能

## 4. 設計原則との整合性

### 4.1 SSoT (Single Source of Truth)
- **グローバル設定**: `settings.polling` テーブルが唯一の真実
- **カメラ個別設定**: `cameras` テーブルが唯一の真実
- **適用ロジック**: `SnapshotService`が単一責任で管理

### 4.2 SOLID原則
- **単一責任**: `SnapshotService`がタイムアウト適用の唯一の責務
- **開放閉鎖**: 新しいタイムアウトタイプ追加時も既存コード変更最小
- **依存逆転**: `SnapshotService`は設定値を外部から注入される

### 4.3 MECE (漏れなくダブりなく)
タイムアウト適用の決定木:
```
カメラXのスナップショット取得時
├─ カメラXにcustom_timeout_enabled=1?
│  ├─ YES → カメラXのtimeout_main_sec/timeout_sub_secを使用
│  └─ NO  → settings.pollingのtimeout_main_sec/timeout_sub_secを使用
└─ タイムアウト値が取得できない場合（異常系）
   └─ ハードコードのデフォルト値（10秒/20秒）を使用
```

**MECEであることの検証**:
- ✅ 漏れなし: すべてのカメラは必ずいずれかのタイムアウト値を持つ
- ✅ ダブりなし: 各カメラに対する適用ルールは一意に定まる

### 4.4 アンアンビギュアス（曖昧さの排除）

**曖昧な表現の排除**:
- ❌ 「適切なタイムアウト値」 → ✅ 「5秒～120秒の範囲で設定可能」
- ❌ 「設定が反映される」 → ✅ 「保存後、次回の巡回サイクルから適用」
- ❌ 「デフォルト値を使う」 → ✅ 「settings.pollingのtimeout_main_sec/timeout_sub_secを使用」

**動作の明確化**:
1. **保存タイミング**: UIで保存ボタン押下時に即座にDBへ書き込み
2. **適用タイミング**: 次回のポーリングサイクル開始時にConfigStoreから読み込み
3. **優先順位**: カメラ個別設定 > グローバル設定 > ハードコードデフォルト

## 5. 依存関係と実装順序

```
[Phase 1: グローバル設定実装]
1. DB: settings.pollingに値追加（完了済み）
2. Backend: API実装 (GET/PUT /api/settings/timeouts)
3. Backend: SnapshotServiceの設定読み込み実装
4. Frontend: SettingsModalにUI追加
5. Test: グローバル設定の動作確認

[Phase 2: カメラ別設定実装]
6. DB: camerasテーブルへカラム追加（migration）
7. Backend: Camera構造体へフィールド追加
8. Backend: SnapshotServiceでカメラ設定優先ロジック
9. Frontend: CameraDetailModalにUI追加
10. Test: カメラ別設定の動作確認

[Phase 3: 統合テスト]
11. Test: フォールバック動作確認
12. Test: 実カメラでの動作確認（.62カメラで検証）
```

**大原則7に基づく宣言**:
優先順位は依存関係と実装順によってのみ定義される。Phase 1完了なしにPhase 2へ進まない。

## 6. テスト計画

### 6.1 単体テスト
- [ ] Backend: タイムアウト値取得APIのテスト
- [ ] Backend: タイムアウト値更新APIのテスト
- [ ] Backend: SnapshotServiceのフォールバックロジックテスト

### 6.2 統合テスト
- [ ] グローバル設定変更 → 次回巡回で反映確認
- [ ] カメラ個別設定ON → グローバルより優先されることを確認
- [ ] カメラ個別設定OFF → グローバルにフォールバックすることを確認
- [ ] 異常系: DB接続失敗時にハードコードデフォルトが使用されることを確認

### 6.3 実UI/UXテスト（Chrome）
- [ ] SettingsModalで値変更 → 保存 → 再度開いて値が保持されているか確認
- [ ] CameraDetailModalでチェックボックスON/OFF → 入力欄の有効/無効が切り替わるか確認
- [ ] 範囲外の値を入力 → バリデーションエラーが表示されるか確認
- [ ] タイムアウト延長後、実際に遅いカメラ（.62）が成功するか確認

### 6.4 パフォーマンステスト
- [ ] 設定変更前後で巡回サイクル時間が適切に変化するか確認
- [ ] タイムアウト30秒設定のカメラが実際に30秒待つか確認（ログで検証）

## 7. リスクと対策

### 7.1 リスク: タイムアウト値が大きすぎる場合の全体パフォーマンス低下
**対策**:
- 入力上限を120秒に制限
- UIに警告メッセージ表示「タイムアウトを長くすると巡回時間が延びます」

### 7.2 リスク: 設定値の不整合（DBとキャッシュ）
**対策**:
- ConfigStoreの既存リフレッシュ機構を活用（5分ごと自動更新）
- 設定変更時に手動リフレッシュAPIを呼び出し

### 7.3 リスク: マイグレーション失敗
**対策**:
- マイグレーション前にバックアップ取得
- ロールバック手順の文書化

## 8. 実装チェックリスト

The_golden_rules.md大原則に基づく実装前チェック：

- [ ] **SSoT**: データソースは一意に定まっているか？
- [ ] **SOLID**: 各モジュールの責務は明確か？
- [ ] **MECE**: 漏れやダブりはないか？
- [ ] **アンアンビギュアス**: 曖昧な表現はないか？
- [ ] **根拠なき自己解釈禁止**: 全ての情報を等価に扱っているか？
- [ ] **現場猫案件禁止**: ハードコードや握り潰しはないか？
- [ ] **優先順位**: 依存関係と実装順は適切か？
- [ ] **チェックリスト**: テスト計画は明確か？

## 9. 受け入れ基準

以下のすべてを満たした場合に完了とする：

1. ✅ すべてのテストケースがパス
2. ✅ 実カメラ（.62）でタイムアウト延長により成功率が改善
3. ✅ UIが直感的で、設定変更が確実に反映される
4. ✅ パフォーマンス劣化がない（巡回時間が過度に延びない）
5. ✅ コードレビューでThe_golden_rules.mdの原則違反がない

## 10. 補足: 調査済み事項

### 10.1 Go2RTCとffmpegの多重アクセス問題
**結論**: 問題なし（設計通り動作）

**検証内容**:
- `snapshot_service/mod.rs` (lines 100-306) のロジック確認
- 優先順位: Go2RTC（recv>0の場合のみ） > ffmpeg（RtspManager経由で排他制御） > HTTP
- Go2RTCとffmpegが同時に同一カメラへアクセスすることはない
- RtspManagerによりffmpeg間の競合も防止済み

**証拠**:
```rust
// lines 267-283: Go2RTC使用判定
let has_active_producer = stream.get("producers")
    .and_then(|p| p.as_array())
    .map(|producers| {
        producers.iter().any(|prod| {
            prod.get("recv")
                .and_then(|r| r.as_u64())
                .map(|recv| recv > 0)
                .unwrap_or(false)
        })
    })
    .unwrap_or(false);

if !has_active_producer {
    // Go2RTCにアクティブな接続がない場合のみffmpegへフォールバック
    return Ok(None);
}
```

---

**文書ステータス**: 初版完成
**次のアクション**: GitHub Issue登録 → Phase 1実装開始
