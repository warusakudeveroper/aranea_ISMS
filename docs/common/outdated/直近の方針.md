# NOTE (outdated)

## 修正履歴
- Before: 古い離島運用方針。最新のis04a/is05a修正、HTTPバックオフ/WDT/断片化対策が未反映。
- After: 2025-01時点の実装に合わせて主要方針を追記（productCodeは4桁固定、WDT/セマフォ非介入、HTTPタイムアウト3s＋3連続失敗で30sバックオフ、typeSpecific API分離、パルス開始/終了時はforce送信）。旧本文は参考として残置し、追加で補足を入れた。

# TODO
- 旧本文を全体的に差し替え（以下の「2025-01 現行方針」を本体として再構成する）

---

## 2025-01 現行方針（実装と整合）
- lacisId: `3 + productType(3桁) + mac12 + productCode(4桁)` 固定（"ISMS"末尾は使用しない）。productCodeは0096等の4桁を設定。
- WDT/セマフォ: 非介入が原則。loop内は非ブロッキング、HTTP/JSON生成では`yield()`を適宜呼ぶ。
- HTTP送信: タイムアウト3s。3連続失敗で30sバックオフ（is04a/is05a StateReporter/Webhook）。
- 送信間隔: 心拍・入力変化は最小1s、パルス開始/終了は`force=true`で即時送信（is04a）。
- typeSpecific API: `/api/status`/`/api/config`は共通+typeSpecificブロック。固有APIは`/api/is04a/*`、`/api/is05a/*`で衝突回避済み。
- Web UI: `<script>`タグ補完済み、全JSONはArduinoJson化、デバウンスは`millis()`経過で判定。
- Wi-Fi: cluster1〜6をデフォルト候補として順次試行。AP SSIDは`ar-<device>-<MAC6>`系（各AraneaSettings準拠）。
- バックエンド: araneaDeviceGate（CIC発行）とdeviceStateReportは既存URLを使用。Gate準備中のためPENDING_TESTは継続。

了解です。**「現地で疎通さえ取れればOK / サーバ側は後回し / 離島・VPN運用 / is01だけはOTA不可で固める」**という前提で、**ESP32 DevKitC + Arduino CLI**で is01〜is05 を作るための“実装仕様（=何を作れば現場で回るか）”を、共通モジュール→デバイス別の順でまとめます。
（※Zero3 は“ローカル受信・中継”として位置付け、ESP32 側はそれに送れる/表示できることを優先します）

---

## 0) まず重要：LacisID 形式の整合（今後の破綻を防ぐ）

GitHub側の仕様とサーバ実装は **araneaDevice の LacisID を `[1,3,12,4]`（Prefix=3 / ProductType3 / MAC12 / ProductCode4）**で扱う前提です 。
`araneaDeviceGate` の検証も **最後の4文字を productCode として一致チェック**します 。

* あなたが書かれた `...ISMS` を **LacisID末尾に入れる**なら、**productCode を “ISMS” として扱う（4文字なので長さは満たす）**必要があります（サーバへ送る `deviceMeta.productCode` も “ISMS” に合わせる）。
* ただし GitHubドキュメント上は productCode は「4桁コード」想定なので 、将来 UI/バリデーション等が厳密化されたときに詰まる可能性があります。

**現地優先の現実解（おすすめ）**

* **“登録・認証に使う lacisId” は `...0001` 等の4桁 productCode**に寄せる
* 画面表示やログ上の識別として **projectTag="ISMS"** を別項目で持つ（display/HTTPで表示）

この方針だと後でサーバが固まっても破綻しにくいです。

---

## 1) 離島運用の全体アーキ（最小構成）

### ローカル（島内）で成立させるもの

* **is01**：電池・DeepSleep・BLE広告のみ（＝これが“固める対象”）
* **Zero3 ×2**：常時 BLE スキャンして **受信ログをローカル保持・Web表示**（疎通確認の主役）

  * 余裕があれば「溜めてからクラウドへ送る」も後付け可能
* **is02/is04/is05**：Wi-Fi機器は **“Zero3リレー（HTTP or MQTT）”へ投げればOK**
  → クラウド未完成でも、島内で状態/制御の動作確認ができる

### 送信先の優先順位（共通仕様）

* settingManager に **relay.primary / relay.secondary（Zero3-1/Zero3-2）**を持つ
* 送信は **primary → 失敗したら secondary**（以降は一定時間ごとに primary へ復帰試行）

---

## 2) 共通モジュール仕様（クラスごとに“実装すべき最低限”）

あなたの定義をベースに、**is01にも必要/不要を明確化**します。

### 2-1. `lacisIDGenerator`

**目的**：ESP32の STA MAC から **必ず同じ lacisID を再生成**する（ハードリセット耐性）。

* 入力：`productType(3桁)`, `productCode(4桁)`（or “ISMS”採用なら4文字固定）
* 出力：`lacisId = "3" + productType + mac12 + productCode`（合計20） 
* 実装要件：

  * STA MAC を **12hex（ハイフンなし）**に正規化
  * 小文字/大文字は統一（おすすめ：大文字）

### 2-2. `araneaRegister`

**目的**：`araneaDeviceGate` に登録し `cic_code` を取得して保存する。

* is01も「初回だけWi-Fiでアクティベート」するなら必須
* 実装要件（最低限）：

  * WiFi接続済み前提で `POST /araneaDeviceGate` を叩く
  * 保存する値：`cic_code`, `stateEndpoint`, `registeredAt`, `lastRegisterError`
* サーバ側リクエストは `deviceMeta.productType/productCode/macAddress` を必須として受けます 

### 2-3. `wifiManager`

**目的**：現地で繋がるまで **cluster1〜6へ順次試行**（ハードコード初期値）。

* `cluster{1..6}` / `isms12345@` を初期候補として内蔵
* 接続成功したら `WiFi.setHostname(hostname)`（表示・mDNSと合わせる）

### 2-4. `displayManager`（I2C OLED 128x64）

**目的**：PC無しでも状態が分かること（現地最優先）。

* is01：CIC + 計測値 + “次回送信まで”など
* is02/is04/is05：IP / CIC / 動作モード / エラー / 最終受信・送信時刻

### 2-5. `ntpManager`

* is01：基本不要（DeepSleep運用＋BLEだけなら、時刻は“相対”でOK）
* is02/is04/is05：Wi-Fi確立後にNTP同期（ログ/送信timestamp用）

### 2-6. `settingManager`

**目的**：初回起動時の defaults を書き込み、以降の設定永続化。

* is01：NVS（Preferences）だけで足りる（SPIFFS無しでもOK）
* is02/is04/is05：SPIFFS or LittleFS を推奨（設定JSONを扱いやすい）

最低限持つキー（あなたの要件を整理）：

* `wifi`: 既定候補 + 追加の優先SSID（後でUIから追加可能）
* `hostname`
* `rebootSchedule`
* `endpoint.cloud`（後で使う）
* `endpoint.relay.primary/secondary`（Zero3）
* `auth`: `tid`, `lacisId`, `cic_code`（登録後に確定）

### 2-7. `HTTPManager`（is01不要）

* 認証：パスコードのみ（初期`0000`・変更可）
* 表示：settingsと稼働ステータス、ログ（直近N件）

### 2-8. `otaManager`（is01不要）

* ArduinoOTA か HTTP Update
* “relay/secondary” 経由でも落とせるよう **URL指定型**が扱いやすい

### 2-9. `SPIFFSManager`（is01不要）

* 初期化、read/write、factoryReset（GPIO26長押し等でformat）

### 2-10. `Operator`（重要）

**目的**：競合しやすい処理を “順序保証” して落ちないようにする。
最低限、以下の **フラグ/状態機械**を持たせます：

* `i2cReady / i2cBusy`
* `wifiReady`
* `ntpReady`
* `httpReady`
* `otaReady`
* `lastError`（原因をOLEDに出す）
* `mode`（PROVISION / RUN / MAINTENANCE / FAILSAFE）

特に is01 は **DeepSleep復帰→I2C初期化の順序**がシビアなので、**I2C関連は全て同期的に直列実行**（割り込み/並列にしない）をルール化。

---

## 3) デバイス別仕様（is01〜is05）

### 3-1. is01（電池・BLE広告・DeepSleep・現地最重要）

**目的**：温湿度を **BLE Advertising**で送る。Wi-Fiは「初回アクティベートのためだけ」に限定。

#### 動作モード

* **PROVISION（未登録）**

  1. WiFi接続（wifiManager）
  2. araneaRegister で `cic_code` 取得し保存
  3. RUNへ移行
* **RUN（通常）**：3分周期で起床→測定→表示→広告→Sleep
* **FAILSAFE（WiFi登録失敗）**：CIC無しでも広告は出す（Zero3で受信確認ができることが最優先）

#### 時系列（あなたが挙げた順序を“落ちない仕様”に固定）

1. **GPIO5（省電力ゲート）制御**

   * `MOSFET_EN` として扱い、**起床直後に既知の安全レベル**を出す
2. **I2C初期化（Wire.begin→デバイス検出）**

   * ここは必ず同期（失敗ならリトライ回数固定）
3. **SHT30取得**
4. **OLED表示（10秒）**
5. **BLE Advertise開始（表示と並行でも可）**
6. Advertise停止 → **DeepSleep突入**

> is01は「I2C初期化でコケやすい」前提なので、`Operator`で **I2C処理は必ず1スレッド（loop内直列）**に固定。

#### BLE広告フォーマット（Zero3で確実に復元できる形）

**“20文字lacisIdをそのまま載せない”**ほうが堅いです（31byte制約）。
推奨：**MAC + productType/productCode を載せて Zero3側で lacisId を再構成**。

* Manufacturer Specific Data（例）

  * `ver(1)`
  * `productType(uint16)`
  * `productCode(uint16)`
  * `mac(6)`
  * `ts(uint32)`（起床回数 or epoch秒）
  * `temp(int16, ×100)`
  * `hum(uint16, ×100)`
  * `battery(uint8, %)`
  * `flags(uint8)`（reed/ボタン等）

Zero3はこれを受けて
`lacisId = "3" + productType(3桁ゼロ埋め) + mac12 + productCode(4桁ゼロ埋め)`
を生成できる（＝サーバ仕様と一致） 

---

### 3-2. is02（Wi-Fi常時・BLE受信・中継）

**目的（現地運用）**：クラウド未完成でも、**Zero3へ投げて疎通確認**できること。
（将来は cloud endpoint にも送れるようにする）

#### ハード要件の一例（テンプレ参照）

is02は pinLayout として `GPIO5=mosfet output / GPIO16,17,19=input pulldown / I2C 21/22` が想定されています （※これは“テンプレ”なので実配線と合わせて確定）。

#### 受信→送信のパイプライン

* BLE scan（常時）
  → is01の manufacturer data を解析
  → `ReceivedRecord{lacisId,temp,hum,battery,rssi,observedAt,gatewayId}` を作る
* 送信先：`relay.primary`（Zero3-1）へ HTTP POST

  * 失敗：`relay.secondary`（Zero3-2）へフォールバック
* OLED：IP / 受信数 / 最終受信 / 最終送信エラーを表示

#### 重複（冗長ゲートウェイの前提）

Zero3が2台あるため、**同じ広告が2台に入る**のは前提。

* is02側は dedupしなくていい（軽くする）
* Zero3側が “受信時刻±数秒” などでまとめて捌く（後回しOK）

---

### 3-3. is04（接点出力：現地はローカルMQTT/HTTPで十分）

**目的（現地疎通）**：

* Wi-Fiで生きている
* 外部から開閉（GPIO12/14）できる
* 画面で状態が分かる
  これだけでOK。

#### 制御経路（現地用）

サーバ未完成なので、is04はまず **Zero3上のローカルMQTT broker（例：mosquitto）**を前提にすると楽です。

* topic例

  * `local/aranea/{rid}/{lacisId}/cmd`（ridグループ制御もここで実現）
* payload例

  * `{ "action":"pulse", "ch":1, "ms":500 }`

#### スイッチ

* tact SW：`wifiReconnect` と `reboot`（GPIO25/26運用）

  * 現地では「押すと何が起きたか」をOLEDに必ず表示

---

### 3-4. is05（8chリード入力：状態をローカルへ上げる）

**目的（現地疎通）**：

* 8chの開閉状態が読める
* 変化があったら Zero3へ送れる
* OLEDに現在値が出る

#### 8ch入力の基本仕様

* input は **pullup/pulldown を配線に合わせて統一**
* チャタリング/瞬断があるので

  * サンプル周期（例：20ms）
  * 安定判定（例：3連続一致）
    を仕様として固定

#### “どの窓か”のマッピング（あなたの方針に合わせる）

* 設定で `ch0..7 → did(8桁) / name / polarity` を保持
* publish時には

  * `did` を必ず載せる
  * “open/close の定義”は polarity で反転可能にする

#### 送信（現地用）

* Zero3 relay に HTTP POST でOK（MQTTでも可）
* 送信は “変化時のみ” にして通信とログを抑える

---

## 4) Arduino CLI 前提のプロジェクト構成（実装が破綻しない形）

### 推奨ディレクトリ

* `firmware/common/`：共通クラス（上記）
* `firmware/devices/is01/`, `is02/`, `is04/`, `is05/`：各 main
* `firmware/lib/`：依存ライブラリ（ArduinoJson / NimBLE / SSD1306 / SHT31 など）

### ビルド時に確定させる定数（事故を防ぐ）

* `DEVICE_TYPE`（例：`ISMS_ar-is01`）
* `PRODUCT_TYPE`（3桁文字列）
* `PRODUCT_CODE`（4桁 or 4文字）
* `DEFAULT_SSID_LIST`（cluster1..6）
* `DEFAULT_RELAY_PRIMARY/SECONDARY`（Zero3）

これらは **コンパイルフラグ（build.extra_flags）**で差し込むと運用が楽です。

---

## 5) いま作るべき“最低限の完成ライン”（現地投入の判定基準）

### is01（必須・固める）

* DeepSleep復帰でも **I2C初期化→SHT30→OLED表示→BLE広告→sleep** が落ちない
* CIC未取得でも **BLE広告は必ず出る**（Zero3で検知できる）
* OLEDに `lacisId(短縮)` / `CIC` / `Temp/Hum` / `err` が出る

### is02/is04/is05（OTA前提で良い）

* Wi-Fi接続とOLED表示が安定
* Zero3（primary/secondary）へ投げられる（HTTP or MQTT）
* OTAで更新できる（後から何とでもなる）

---
